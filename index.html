<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebéŸ³é¢‘å·¥åŠ V12 - å®æ—¶äº¤äº’ç‰ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <style>
        :root { --primary: #2980b9; --accent: #e74c3c; --start: #27ae60; --end: #c0392b; --bg: #f5f6fa; --card: #ffffff; --text: #2c3e50; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: var(--bg); color: var(--text); padding: 10px; display: flex; justify-content: center; margin: 0; min-height: 100vh; box-sizing: border-box; }
        
        .container { width: 100%; max-width: 850px; background: var(--card); padding: 20px; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.08); display: flex; flex-direction: column; gap: 12px; }
        
        .header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee; padding-bottom: 10px; margin: 0; }
        h1 { margin: 0; font-size: 1.3rem; color: var(--primary); }
        .btn-reset { background: #ecf0f1; color: #7f8c8d; border: 1px solid #bdc3c7; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 0.85rem; transition:0.2s; }
        .btn-reset:hover { background: #bdc3c7; color: white; }

        .upload-box { border: 2px dashed #bdc3c7; padding: 10px; border-radius: 8px; background: #fcfcfc; cursor: pointer; transition: 0.2s; display: flex; align-items: center; justify-content: center; gap: 15px; min-height: 45px; }
        .upload-box:hover { border-color: var(--primary); background: #ebf5fb; }
        .upload-icon { font-size: 1.4rem; }
        .upload-text h3 { margin: 0; font-size: 0.95rem; color: #34495e; }
        .upload-text p { margin: 0; font-size: 0.75rem; color: #7f8c8d; }

        .info-bar { display: flex; flex-wrap: wrap; gap: 15px; background: #ecf0f1; padding: 8px 12px; border-radius: 6px; font-size: 0.85em; color: #7f8c8d; border-left: 4px solid var(--primary); align-items: center; }
        .info-item b { color: #2c3e50; margin-right: 4px; }
        .tag { background: #fff; padding: 1px 6px; border-radius: 4px; font-weight: bold; color: var(--primary); font-size: 0.8em; }

        /* æ³¢å½¢å›¾å®¹å™¨ */
        .vis-container { 
            position: relative; 
            width: 100%; 
            height: 120px; 
            background: #f0f3f5; 
            border: 1px solid #bdc3c7; 
            border-radius: 4px; 
            overflow: hidden; 
            cursor: pointer; 
            user-select: none;
        }
        .vis-container:hover { border-color: var(--primary); }
        
        canvas { width: 100%; height: 100%; display: block; }
        
        /* æ’­æ”¾å¤´ */
        .play-head { position: absolute; top:0; left:0; width: 2px; height: 100%; background: var(--accent); pointer-events: none; display: none; z-index: 10; box-shadow: 0 0 5px rgba(231, 76, 60, 0.8); }

        .tips { font-size: 0.8em; color: #7f8c8d; text-align: center; background: #fafafa; padding: 5px; border-radius: 4px; border: 1px dashed #eee; }
        .tips b { color: #2c3e50; }

        .control-group { display: flex; flex-direction: column; gap: 10px; }
        .row { display: flex; align-items: center; gap: 10px; }
        .label { width: 70px; font-weight: 700; font-size: 0.9em; flex-shrink: 0; color: #34495e; }
        
        /* å‰ªåˆ‡é¢æ¿ */
        .cut-panel { background: #f4f6f7; padding: 10px; border-radius: 8px; border: 1px solid #e0e0e0; display: flex; flex-direction: column; gap: 8px; }
        .cut-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        .time-input { width: 65px; padding: 5px; border: 1px solid #bdc3c7; border-radius: 4px; text-align: center; font-family: monospace; font-weight: bold; color: var(--primary); }
        .btn-preview { background: #34495e; color: white; border:none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em; width: 100%; }
        .btn-preview:hover { background: #2c3e50; }

        /* è‡ªåŠ¨åˆ†æ®µ */
        .split-panel { background: #fff8e1; border: 1px solid #ffe082; padding: 10px; border-radius: 8px; margin-top: 5px; display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .input-mini { width: 50px; padding: 5px; border: 1px solid #ffe082; border-radius: 4px; text-align: center; }
        .btn-split { background: #f39c12; color: white; border: none; padding: 6px 15px; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 0.9em; }

        input[type=range] { flex: 1; height: 6px; border-radius: 3px; background: #bdc3c7; -webkit-appearance: none; outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--primary); cursor: pointer; transition: 0.1s; }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        .val-badge { background: var(--primary); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.75em; min-width: 35px; text-align: center; }

        .export-panel { border-top: 1px dashed #ccc; padding-top: 15px; margin-top: 5px; }
        .setting-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 10px; }
        .setting-item label { display: block; font-size: 0.75em; color: #95a5a6; margin-bottom: 3px; }
        select { width: 100%; padding: 6px; border: 1px solid #bdc3c7; border-radius: 4px; font-size: 0.85em; background: white; }
        
        .btn-dl { width: 100%; padding: 12px; background: var(--success); color: white; font-size: 1.1rem; border-radius: 6px; border: none; cursor: pointer; font-weight: bold; box-shadow: 0 4px 0 #219150; transition: 0.1s; }
        .btn-dl:active { transform: translateY(4px); box-shadow: none; }

        .hidden { display: none !important; }
        #loader { display: none; position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(255,255,255,0.95); z-index: 999; flex-direction: column; justify-content: center; align-items: center; }
        .spinner { width: 30px; height: 30px; border: 3px solid #eee; border-top: 3px solid var(--primary); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>ğŸ§ Web éŸ³é¢‘å·¥åŠ V12</h1>
        <button class="btn-reset" onclick="resetParams()">â†º é‡ç½®å‚æ•°</button>
    </div>

    <div id="loader">
        <div class="spinner"></div>
        <div style="margin-top:10px; color:#555; font-size:0.9em;" id="loaderText">å¤„ç†ä¸­...</div>
    </div>

    <div class="upload-box" onclick="document.getElementById('fileInput').click()">
        <div class="upload-icon">ğŸ‘†</div>
        <div class="upload-text">
            <h3>ç‚¹å‡»ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶</h3>
            <p>æ”¯æŒ MP3, M4A, WAV, FLAC</p>
        </div>
        <input type="file" id="fileInput" accept="audio/*,.m4a,.mp3,.wav,.aac,.flac" style="display:none">
    </div>

    <div id="workspace" class="hidden">
        <div class="info-bar">
            <div class="info-item"><b>æ–‡ä»¶:</b> <span id="mName">-</span></div>
            <div class="info-item"><b>æ—¶é•¿:</b> <span id="mDur">-</span></div>
            <div class="info-item"><b>æ ¼å¼:</b> <span id="mParams">-</span></div>
            <div class="tag" id="mBitrate">- kbps</div>
        </div>

        <div class="tips">
            ğŸ–±ï¸ <b>å•å‡»</b>æ³¢å½¢ï¼šç«‹å³ä»ç‚¹å‡»å¤„æ’­æ”¾ | ğŸ–±ï¸ğŸ–±ï¸ <b>åŒå‡»</b>æ³¢å½¢ï¼šä¾æ¬¡è®¾ç½® <span style="color:var(--start)">èµ·ç‚¹</span> å’Œ <span style="color:var(--end)">ç»ˆç‚¹</span>
        </div>

        <!-- æ³¢å½¢å›¾å®¹å™¨ -->
        <div class="vis-container" id="waveformBox">
            <canvas id="visualizer"></canvas>
            <div id="playHead" class="play-head"></div>
        </div>

        <div class="row" style="margin-top:5px; margin-bottom: 5px;">
            <button class="btn-reset" id="btnStop" style="background:#95a5a6; color:white; border:none; padding:8px 15px;">â¹ åœæ­¢æ’­æ”¾</button>
            <span id="timeDisplay" style="font-family:monospace; margin-left:auto; color:#2c3e50; font-weight:bold; font-size:1.1em;">00:00.00</span>
        </div>

        <div class="control-group" style="margin-top:5px;">
            <div class="row">
                <div class="label">ğŸš€ å˜é€Ÿ</div>
                <input type="range" id="rateInput" min="0.5" max="2.0" step="0.1" value="1.0">
                <div class="val-badge" id="rateVal">1.0x</div>
            </div>
            <div class="row">
                <div class="label">ğŸ”Š éŸ³é‡</div>
                <input type="range" id="volInput" min="0" max="3" step="0.1" value="1.0">
                <div class="val-badge" id="volVal">100%</div>
            </div>
            <div class="row">
                <div class="label">ğŸ‘» ç‰¹æ•ˆ</div>
                <input type="checkbox" id="reverseCheck" style="margin:0;">
                <label for="reverseCheck" style="font-size:0.9em; margin:0;">å€’æ”¾é€‰åŒº</label>
            </div>
        </div>

        <div class="cut-panel">
            <div class="cut-row">
                <div class="label" style="width:auto; color:var(--start)">âœ‚ï¸ èµ·ç‚¹:</div>
                <input type="number" id="trimStart" class="time-input" value="0.00" step="0.1" min="0">
                
                <div style="width:10px;"></div>
                
                <div class="label" style="width:auto; color:var(--end)">âœ‚ï¸ ç»ˆç‚¹:</div>
                <input type="number" id="trimEnd" class="time-input" value="0.00" step="0.1" min="0">
            </div>
            <div class="cut-row" style="margin-top:5px;">
                <button class="btn-preview" id="btnPlaySeg">â–¶ é¢„è§ˆé€‰ä¸­ç‰‡æ®µ (Preview Selection)</button>
            </div>
        </div>

        <div class="split-panel">
            <span style="font-size:0.9em; font-weight:bold; color:#f39c12">ğŸ“‚ è‡ªåŠ¨åˆ†æ®µ:</span>
            <span style="font-size:0.85em; color:#666;">åˆ‡åˆ†ä¸º</span>
            <input type="number" id="splitCount" class="input-mini" value="2" min="2" step="1">
            <span style="font-size:0.85em; color:#666;">æ®µ</span>
            <button class="btn-split" id="btnBatchSplit">âš¡ æ‰¹é‡åˆ‡åˆ†å¹¶ä¸‹è½½</button>
        </div>

        <div class="export-panel">
            <div class="setting-grid">
                <div class="setting-item">
                    <label>æ ¼å¼</label>
                    <select id="exportFormat"><option value="mp3">MP3</option><option value="wav">WAV</option></select>
                </div>
                <div class="setting-item" id="bitrateGroup">
                    <label>ç ç‡</label>
                    <select id="exportBitrate">
                        <option value="320">320k</option><option value="128" selected>128k</option><option value="64">64k</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label>é‡‡æ ·ç‡</label>
                    <select id="exportRate">
                        <option value="original">åŸå§‹</option><option value="44100">44100Hz</option><option value="22050">22050Hz</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label>å£°é“</label>
                    <select id="exportChannels"><option value="original">åŸå§‹</option><option value="1">å•å£°é“</option></select>
                </div>
            </div>
            
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                <span style="font-size:0.85em; color:#7f8c8d; font-weight:bold;" id="estSizeDisplay">é¢„ä¼°å¤§å°: -</span>
            </div>
            <button class="btn-dl" id="btnDownload">ğŸ’¾ å¯¼å‡ºå½“å‰ç‰‡æ®µ</button>
        </div>
    </div>
</div>

<script>
    let audioCtx;
    let originalBuffer = null; 
    let sourceNode = null;
    let gainNode = null;
    
    let isPlaying = false;
    let startTime = 0;      
    let startOffset = 0;    
    let playMode = 'full';  // 'full' | 'segment'
    
    // åŒå‡»é€»è¾‘çŠ¶æ€
    let nextClickIsStart = true; // true=è®¾èµ·ç‚¹, false=è®¾ç»ˆç‚¹

    let rawFileName = "audio"; 
    let rawFileSize = 0; 

    const el = (id) => document.getElementById(id);
    const UI = {
        file: el('fileInput'),
        workspace: el('workspace'),
        btnSeg: el('btnPlaySeg'),
        btnStop: el('btnStop'),
        tStart: el('trimStart'),
        tEnd: el('trimEnd'),
        head: el('playHead'),
        time: el('timeDisplay'),
        cvsBox: el('waveformBox'),
        cvs: el('visualizer'),
        rate: el('rateInput'),
        rateVal: el('rateVal'),
        vol: el('volInput'),
        volVal: el('volVal'),
        rev: el('reverseCheck'),
        fmt: el('exportFormat'),
        br: el('exportBitrate'),
        est: el('estSizeDisplay'),
        splitN: el('splitCount'),
        btnSplit: el('btnBatchSplit'),
        btnDl: el('btnDownload')
    };

    // 1. åˆå§‹åŒ–
    UI.file.addEventListener('change', async function() {
        if(!this.files.length) return;
        const file = this.files[0];
        this.value = ''; 
        showLoader('æ­£åœ¨è§£ç ...');
        rawFileSize = file.size;
        rawFileName = file.name.replace(/\.[^/.]+$/, ""); 

        try {
            if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if(audioCtx.state === 'suspended') await audioCtx.resume();

            const arrayBuf = await file.arrayBuffer();
            originalBuffer = await audioCtx.decodeAudioData(arrayBuf);

            el('mName').innerText = file.name;
            el('mDur').innerText = formatTimeFull(originalBuffer.duration).split('.')[0];
            el('mParams').innerText = `${originalBuffer.sampleRate}Hz/${originalBuffer.numberOfChannels}ch`;
            const estKbps = Math.round((file.size * 8) / originalBuffer.duration / 1000);
            el('mBitrate').innerText = `~${estKbps}kbps`;

            UI.tStart.value = "0.00";
            UI.tEnd.value = originalBuffer.duration.toFixed(2);
            nextClickIsStart = true;

            el('workspace').classList.remove('hidden');
            stopAudio();
            drawStaticWave();
            updateEstimate();

        } catch(e) { alert('é”™è¯¯: '+e.message); } finally { hideLoader(); }
    });

    // 2. å®æ—¶äº¤äº’é€»è¾‘ (æ ¸å¿ƒä¿®å¤)
    // ç›‘å¬ input äº‹ä»¶å®ç°å®æ—¶åé¦ˆ
    UI.rate.addEventListener('input', function() {
        const val = parseFloat(this.value);
        UI.rateVal.innerText = val + 'x';
        // å®æ—¶ä¿®æ”¹æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘
        if(isPlaying && sourceNode) {
            sourceNode.playbackRate.value = val;
        }
        updateEstimate();
    });

    UI.vol.addEventListener('input', function() {
        const val = parseFloat(this.value);
        UI.volVal.innerText = Math.round(val * 100) + '%';
        // å®æ—¶ä¿®æ”¹æ­£åœ¨æ’­æ”¾çš„éŸ³é‡
        if(isPlaying && gainNode) {
            gainNode.gain.value = val;
        }
    });

    // 3. é¼ æ ‡äº¤äº’ (å•å‡»æ’­æ”¾ï¼ŒåŒå‡»è®¾ç‚¹)
    UI.cvsBox.addEventListener('click', (e) => {
        // å•å‡»é€»è¾‘: è·³è½¬å¹¶æ’­æ”¾
        if(!originalBuffer) return;
        const rect = UI.cvsBox.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        const seekTime = percent * originalBuffer.duration;
        
        startOffset = seekTime;
        playMode = 'full';
        
        // æ— è®ºå½“å‰æ˜¯å¦æ’­æ”¾ï¼Œéƒ½ä»æ–°ä½ç½®é‡æ–°å¼€å§‹æ’­æ”¾
        stopAudio(false, false); // ä¸é‡ç½®offset
        playAudio('full');
    });

    UI.cvsBox.addEventListener('dblclick', (e) => {
        // åŒå‡»é€»è¾‘: è®¾ç‚¹
        e.stopPropagation(); // é˜²æ­¢å†’æ³¡
        if(!originalBuffer) return;
        const rect = UI.cvsBox.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        const clickTime = percent * originalBuffer.duration;

        if(nextClickIsStart) {
            // è®¾èµ·ç‚¹
            if(clickTime >= parseFloat(UI.tEnd.value)) UI.tEnd.value = originalBuffer.duration.toFixed(2);
            UI.tStart.value = clickTime.toFixed(2);
            nextClickIsStart = false; // ä¸‹æ¬¡è®¾ç»ˆç‚¹
        } else {
            // è®¾ç»ˆç‚¹
            if(clickTime <= parseFloat(UI.tStart.value)) { 
                alert("ç»ˆç‚¹ä¸èƒ½æ—©äºèµ·ç‚¹"); return; 
            }
            UI.tEnd.value = clickTime.toFixed(2);
            nextClickIsStart = true; // ä¸‹æ¬¡è®¾èµ·ç‚¹
        }
        drawStaticWave();
        updateEstimate();
    });

    // 4. æ’­æ”¾æ§åˆ¶
    UI.btnSeg.addEventListener('click', () => {
        if(isPlaying && playMode === 'segment') stopAudio();
        else {
            stopAudio();
            playAudio('segment');
        }
    });
    UI.btnStop.addEventListener('click', () => stopAudio());

    function playAudio(mode) {
        if(!originalBuffer) return;
        playMode = mode;
        
        let bufferToPlay = originalBuffer;
        let playStart = 0; 
        let duration = originalBuffer.duration;

        if(mode === 'segment') {
            const seg = getSegmentBuffer(UI.rev.checked);
            if(!seg) return;
            bufferToPlay = seg;
            duration = seg.duration;
            playStart = 0; 
        } else {
            playStart = startOffset; 
        }

        sourceNode = audioCtx.createBufferSource();
        sourceNode.buffer = bufferToPlay;
        sourceNode.playbackRate.value = UI.rate.value; // åº”ç”¨å½“å‰é€Ÿåº¦
        
        gainNode = audioCtx.createGain();
        gainNode.gain.value = UI.vol.value; // åº”ç”¨å½“å‰éŸ³é‡
        
        sourceNode.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        startTime = audioCtx.currentTime;
        sourceNode.start(0, playStart);
        isPlaying = true;

        if(mode === 'segment') UI.btnSeg.innerText = "â¹ åœæ­¢é¢„è§ˆ";
        
        requestAnimationFrame(updatePlayHead);

        sourceNode.onended = () => {
            const playedTime = (audioCtx.currentTime - startTime) * parseFloat(UI.rate.value);
            if(playedTime >= duration - playStart - 0.1) stopAudio(true);
        };
    }

    function stopAudio(reset = false, updateOffset = true) {
        if(sourceNode) try{sourceNode.stop()}catch(e){}
        
        if(isPlaying && playMode === 'full' && updateOffset) {
            const elapsed = (audioCtx.currentTime - startTime) * parseFloat(UI.rate.value);
            startOffset += elapsed;
            if(startOffset >= originalBuffer.duration || reset) startOffset = 0;
        }
        
        isPlaying = false;
        UI.btnSeg.innerText = "â–¶ é¢„è§ˆé€‰ä¸­ç‰‡æ®µ (Preview Selection)";
        
        if(playMode === 'full') updatePlayHeadUI(startOffset);
        else UI.head.style.display = 'none';

        drawStaticWave();
    }

    // 5. å¯è§†åŒ–ç»˜åˆ¶
    function updatePlayHead() {
        if(!isPlaying) return;
        requestAnimationFrame(updatePlayHead);
        
        const rate = parseFloat(UI.rate.value);
        let currentSec = (audioCtx.currentTime - startTime) * rate;
        
        if(playMode === 'full') {
            currentSec += startOffset;
            UI.time.innerText = formatTimeFull(currentSec);
            const percent = currentSec / originalBuffer.duration;
            UI.head.style.display = 'block';
            UI.head.style.left = (percent * 100) + '%';
        } else {
            UI.time.innerText = "é¢„è§ˆ: " + formatTimeFull(currentSec);
            UI.head.style.display = 'none'; 
        }
    }

    function updatePlayHeadUI(time) {
        if(!originalBuffer) return;
        const percent = time / originalBuffer.duration;
        UI.head.style.display = 'block';
        UI.head.style.left = (percent * 100) + '%';
    }

    function drawStaticWave() {
        const cvs = UI.cvs;
        const ctx = cvs.getContext('2d');
        const w = cvs.width = cvs.clientWidth; 
        const h = cvs.height = cvs.clientHeight;
        
        ctx.clearRect(0,0,w,h);
        ctx.fillStyle = '#f0f3f5'; ctx.fillRect(0,0,w,h);
        if(!originalBuffer) return;

        const data = originalBuffer.getChannelData(0);
        const step = Math.ceil(data.length/w);
        const amp = h/2;
        
        const dur = originalBuffer.duration;
        const s = parseFloat(UI.tStart.value);
        const e = parseFloat(UI.tEnd.value);
        const xS = (s/dur)*w;
        const xE = (e/dur)*w;
        
        // ç»˜åˆ¶æ³¢å½¢
        ctx.beginPath();
        for(let i=0; i<w; i++){
            let min=1.0, max=-1.0;
            for(let j=0; j<step; j++){
                let v=data[i*step+j]; if(v<min)min=v; if(v>max)max=v;
            }
            if(i<xS || i>xE) ctx.fillStyle = '#bdc3c7'; // ç°è‰²(æœªé€‰)
            else ctx.fillStyle = '#3498db'; // è“è‰²(é€‰ä¸­)
            ctx.fillRect(i, (1+min)*amp, 1, Math.max(1,(max-min)*amp));
        }

        // ç»˜åˆ¶èµ·æ­¢çº¿
        // èµ·ç‚¹çº¿ (ç»¿)
        ctx.fillStyle = '#27ae60';
        ctx.fillRect(xS, 0, 2, h);
        // ç»ˆç‚¹çº¿ (çº¢)
        ctx.fillStyle = '#c0392b';
        ctx.fillRect(xE, 0, 2, h);
        
        // é®ç½©
        ctx.fillStyle = 'rgba(0,0,0,0.05)';
        ctx.fillRect(0,0,xS,h);
        ctx.fillRect(xE,0,w-xE,h);
    }

    // è¾…åŠ©åŠŸèƒ½
    UI.tStart.addEventListener('change', () => { validateTime(); drawStaticWave(); updateEstimate(); nextClickIsStart=false; });
    UI.tEnd.addEventListener('change', () => { validateTime(); drawStaticWave(); updateEstimate(); nextClickIsStart=true; });
    function validateTime() {
        let s = parseFloat(UI.tStart.value);
        let e = parseFloat(UI.tEnd.value);
        if(s<0) s=0; if(e>originalBuffer.duration) e=originalBuffer.duration;
        if(s>=e) s = e - 0.1;
        UI.tStart.value=s.toFixed(2); UI.tEnd.value=e.toFixed(2);
    }

    UI.btnSplit.addEventListener('click', async () => {
        if(!originalBuffer) return;
        const n = parseInt(UI.splitN.value);
        if(n < 2) return;
        showLoader(`æ­£åœ¨æ‰¹é‡åˆ‡åˆ†ä¸º ${n} æ®µ...`);
        try {
            const totalDur = originalBuffer.duration;
            const segDur = totalDur / n;
            for(let i=0; i<n; i++) {
                const blob = await renderSegmentToBlob(i * segDur, (i+1) * segDur);
                const fname = `${rawFileName}_part${i+1}.${el('exportFormat').value}`;
                triggerDownload(blob, fname);
                await new Promise(r => setTimeout(r, 500));
            }
        } catch(e) { alert('åˆ†æ®µå¤±è´¥: ' + e); } finally { hideLoader(); }
    });

    UI.btnDl.addEventListener('click', async () => {
        if(!originalBuffer) return;
        showLoader('æ­£åœ¨å¯¼å‡º...');
        try {
            const s = parseFloat(UI.tStart.value);
            const e = parseFloat(UI.tEnd.value);
            const blob = await renderSegmentToBlob(s, e);
            const ext = el('exportFormat').value;
            triggerDownload(blob, `${rawFileName}_cut.${ext}`);
        } catch(e) { alert(e); } finally { hideLoader(); }
    });

    // æ¸²æŸ“å‡½æ•°
    async function renderSegmentToBlob(startTime, endTime) {
        const dur = endTime - startTime;
        if(dur <= 0) throw new Error("æ—¶é•¿æ— æ•ˆ");
        const rate = parseFloat(UI.rate.value);
        const vol = parseFloat(UI.vol.value);
        const isRev = UI.rev.checked;
        let tSR = el('exportRate').value==='original' ? originalBuffer.sampleRate : parseInt(el('exportRate').value);
        let tCh = el('exportChannels').value==='original' ? originalBuffer.numberOfChannels : parseInt(el('exportChannels').value);
        const renderDur = dur / rate;
        const offCtx = new OfflineAudioContext(tCh, renderDur * tSR, tSR);
        const cutBuf = audioCtx.createBuffer(originalBuffer.numberOfChannels, Math.floor(dur * originalBuffer.sampleRate), originalBuffer.sampleRate);
        const startFrame = Math.floor(startTime * originalBuffer.sampleRate);
        for(let i=0; i<originalBuffer.numberOfChannels; i++) {
            const old = originalBuffer.getChannelData(i);
            const curr = cutBuf.getChannelData(i);
            for(let j=0; j<cutBuf.length; j++) curr[j] = old[startFrame+j] || 0;
            if(isRev) Array.prototype.reverse.call(curr);
        }
        const src = offCtx.createBufferSource();
        src.buffer = cutBuf; src.playbackRate.value = rate;
        const gain = offCtx.createGain(); gain.gain.value = vol;
        src.connect(gain); gain.connect(offCtx.destination); src.start(0);
        const rendered = await offCtx.startRendering();
        if(el('exportFormat').value === 'mp3') return bufferToMp3(rendered, parseInt(UI.br.value));
        else return bufferToWave(rendered, rendered.length);
    }
    
    function getSegmentBuffer(isRev) {
        const s = parseFloat(UI.tStart.value);
        const e = parseFloat(UI.tEnd.value);
        const dur = e-s; if(dur<=0) return null;
        const f = Math.floor(dur*originalBuffer.sampleRate);
        const b = audioCtx.createBuffer(originalBuffer.numberOfChannels, f, originalBuffer.sampleRate);
        const startF = Math.floor(s*originalBuffer.sampleRate);
        for(let i=0; i<b.numberOfChannels; i++){
            const o = originalBuffer.getChannelData(i);
            const n = b.getChannelData(i);
            for(let k=0; k<f; k++) n[k] = o[startF+k]||0;
            if(isRev) Array.prototype.reverse.call(n);
        }
        return b;
    }

    function triggerDownload(blob, name) {
        const url = URL.createObjectURL(blob); const a = document.createElement('a');
        a.href = url; a.download = name; document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }
    function resetParams() {
        if(!originalBuffer) return;
        UI.rate.value=1; el('rateVal').innerText="1.0x";
        UI.vol.value=1; el('volVal').innerText="100%";
        UI.rev.checked=false;
        UI.tStart.value="0.00"; UI.tEnd.value=originalBuffer.duration.toFixed(2);
        stopAudio();
        drawStaticWave(); updateEstimate();
    }
    function updateEstimate() {
        if(!originalBuffer) return;
        const dur = Math.max(0, parseFloat(UI.tEnd.value)-parseFloat(UI.tStart.value));
        const rDur = dur / parseFloat(UI.rate.value);
        let bytes=0;
        if(UI.fmt.value==='mp3') bytes = (rDur * parseInt(UI.br.value) * 1000)/8;
        else {
            let sr = el('exportRate').value==='original'?originalBuffer.sampleRate:parseInt(el('exportRate').value);
            let ch = el('exportChannels').value==='original'?originalBuffer.numberOfChannels:parseInt(el('exportChannels').value);
            bytes = rDur*sr*ch*2+44;
        }
        UI.est.innerText = `é¢„ä¼°: ${(bytes/1024/1024).toFixed(2)} MB`;
    }
    [UI.rate, UI.fmt, UI.br, UI.sr, UI.ch].forEach(i=>{i.addEventListener('input', updateEstimate); i.addEventListener('change', updateEstimate); });
    UI.fmt.addEventListener('change', () => { const isMp3 = UI.fmt.value === 'mp3'; el('bitrateGroup').style.opacity = isMp3?'1':'0.3'; UI.br.disabled = !isMp3; });
    function formatTimeFull(s) { const m = Math.floor(s/60); const sec = Math.floor(s%60); const ms = Math.floor((s%1)*100); return `${m.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}.${ms.toString().padStart(2,'0')}`; }
    function showLoader(t){ el('loader').style.display='flex'; el('loaderText').innerText=t; }
    function hideLoader(){ el('loader').style.display='none'; }
    function bufferToMp3(buf, kbps) { const enc = new lamejs.Mp3Encoder(buf.numberOfChannels, buf.sampleRate, kbps); const d=[]; const l=buf.getChannelData(0); const r=buf.numberOfChannels>1?buf.getChannelData(1):undefined; const conv=a=>{const i=new Int16Array(a.length); for(let k=0;k<a.length;k++){let v=Math.max(-1,Math.min(1,a[k])); i[k]=v<0?v*0x8000:v*0x7FFF;} return i;} 
    const lD=conv(l); const rD=r?conv(r):undefined; const bs=1152; for(let i=0;i<lD.length;i+=bs){ const b=enc.encodeBuffer(lD.subarray(i,i+bs), rD?rD.subarray(i,i+bs):undefined); if(b.length>0)d.push(b); } const f=enc.flush(); if(f.length>0)d.push(f); return new Blob(d,{type:'audio/mp3'}); }
    function bufferToWave(b,len){let c=b.numberOfChannels,l=len*c*2+44,bf=new ArrayBuffer(l),v=new DataView(bf),p=0;function u16(x){v.setUint16(p,x,true);p+=2}function u32(x){v.setUint32(p,x,true);p+=4}u32(0x46464952);u32(l-8);u32(0x45564157);u32(0x20746d66);u32(16);u16(1);u16(c);u32(b.sampleRate);u32(b.sampleRate*2*c);u16(c*2);u16(16);u32(0x61746164);u32(l-p-4);let chs=[];for(let i=0;i<c;i++)chs.push(b.getChannelData(i));while(p<l){for(let i=0;i<c;i++){let s=Math.max(-1,Math.min(1,chs[i][(p-44)/2/c]));s=(s<0?s*32768:s*32767)|0;v.setInt16(p,s,true);p+=2;}}return new Blob([bf],{type:'audio/wav'});}
</script>
</body>
</html>